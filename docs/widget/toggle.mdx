---
title: NakedToggle
description: Versatile headless toggle control that can expose button or switch semantics while you keep full visual control
keywords: [flutter, toggle, switch, button, headless, accessibility, widgetstate]
---

NakedToggle exposes binary toggle behaviour (on/off) without shipping any visual opinion. Flip the `asSwitch` flag to change accessibility semantics between a toggle button and a settings switch, then render whatever visuals you need in the builder.

<Info>
  Complete runnable examples live in [`example/lib/api/naked_toggle.0.dart`](https://github.com/btwld/naked_ui/blob/main/example/lib/api/naked_toggle.0.dart).
</Info>

## Quick Start

<CodeGroup title="Toggle Button" defaultLanguage="dart">
```dart
class ToggleButtonExample extends StatefulWidget {
  const ToggleButtonExample({super.key});

  @override
  State<ToggleButtonExample> createState() => _ToggleButtonExampleState();
}

class _ToggleButtonExampleState extends State<ToggleButtonExample> {
  bool _isBold = false;

  @override
  Widget build(BuildContext context) {
    return NakedToggle(
      value: _isBold,
      onChanged: (next) => setState(() => _isBold = next),
      semanticLabel: 'Bold text',
      builder: (context, toggleState, _) {
        final bool isActive = toggleState.isToggled;
        final bool isHovered = toggleState.isHovered;
        final bool isFocused = toggleState.isFocused;

        return AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          width: 40,
          height: 40,
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(8),
            color: isActive
                ? Colors.blue.shade600
                : isHovered
                    ? Colors.grey.shade200
                    : Colors.transparent,
            border: Border.all(
              color: isFocused ? Colors.blue : Colors.grey.shade300,
              width: isFocused ? 2 : 1,
            ),
          ),
          child: Icon(
            Icons.format_bold,
            color: isActive ? Colors.white : Colors.grey.shade800,
          ),
        );
      },
    );
  }
}
```
</CodeGroup>

<Tip>
  Need neutral semantics? Leave `asSwitch` at `false` for button semantics. Flip it to `true` for settings-style switches that announce "on/off" to assistive tech.
</Tip>

## Toggle Builder State

The optional `builder` receives a strongly typed `NakedToggleState`:

- `isToggled` → `bool`: current boolean value
- `isHovered`, `isFocused`, `isPressed`, `isDisabled` → derived from `NakedWidgetState`
- `widgetStates` → raw `Set<WidgetState>` if you need manual resolution

If you prefer simple composition, pass a `child` instead and style it externally.

## Constructor

```dart
const NakedToggle({
  Key? key,
  required this.value,
  this.onChanged,
  this.child,
  this.enabled = true,
  this.mouseCursor,
  this.enableFeedback = true,
  this.focusNode,
  this.autofocus = false,
  this.onFocusChange,
  this.onHoverChange,
  this.onPressChange,
  this.builder,
  this.semanticLabel,
  this.asSwitch = false,
})
```

### Key Properties

- `value` → `bool`: the current on/off state (required)
- `onChanged` → `ValueChanged<bool>?`: called with the next value; omit to render a disabled toggle
- `builder` → `NakedStateBuilder<NakedToggleState>?`: tailor visuals from the typed state snapshot
- `child` → `Widget?`: static child when you do not need dynamic styling
- `asSwitch` → `bool`: `false` (button semantics) or `true` (switch semantics)
- `enableFeedback` → `bool`: haptic/audio feedback on activation (default `true`)
- `focusNode`, `autofocus`, `onFocusChange`, `onHoverChange`, `onPressChange`: tap into interaction lifecycle hooks
- `semanticLabel` → `String?`: accessibility label, especially important when no text label is visible

## Toggle Groups & Segmented Controls

Combine `NakedToggleGroup` and `NakedToggleOption` for radio-like segmented controls:

```dart
class ToggleGroupExample extends StatelessWidget {
  const ToggleGroupExample({super.key, required this.value, required this.onChanged});

  final String value;
  final ValueChanged<String> onChanged;

  @override
  Widget build(BuildContext context) {
    return NakedToggleGroup<String>(
      selectedValue: value,
      onChanged: onChanged,
      child: Row(
        children: [
          NakedToggleOption<String>(
            value: 'grid',
            builder: (context, optionState, _) {
              final isCurrent = optionState.isCurrentSelection;
              return _SegmentChip(label: 'Grid', selected: isCurrent);
            },
          ),
          const SizedBox(width: 8),
          NakedToggleOption<String>(
            value: 'list',
            builder: (context, optionState, _) {
              final isCurrent = optionState.isCurrentSelection;
              return _SegmentChip(label: 'List', selected: isCurrent);
            },
          ),
        ],
      ),
    );
  }
}

class _SegmentChip extends StatelessWidget {
  const _SegmentChip({required this.label, required this.selected});

  final String label;
  final bool selected;

  @override
  Widget build(BuildContext context) {
    return AnimatedContainer(
      duration: const Duration(milliseconds: 150),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(8),
        color: selected ? Colors.blue.shade600 : Colors.grey.shade200,
      ),
      child: Text(
        label,
        style: TextStyle(
          color: selected ? Colors.white : Colors.grey.shade800,
          fontWeight: FontWeight.w600,
        ),
      ),
    );
  }
}
```

`NakedToggleOptionState<T>` mirrors the base state helpers and exposes:
- `value` → the option's value
- `selectedValue` → current group selection
- `isCurrentSelection` → convenience boolean

## Accessibility Notes

- Keyboard: Space/Enter toggles, arrow keys move between options inside a `NakedToggleGroup`
- Screen readers: provide `semanticLabel` (and `asSwitch` when acting as a settings switch)
- Focus management: supply your own `FocusNode` when integrating with larger focus scopes
- Visual feedback: use `toggleState.isFocused` / `isPressed` to surface strong focus & press affordances

Need more patterns? Review the full sample app under `example/lib/api` for end-to-end scenarios.

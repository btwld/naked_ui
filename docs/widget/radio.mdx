---
title: NakedRadio
description: Headless radio button primitives backed by RadioGroup for exclusive selection
keywords: [flutter, radio, radiogroup, headless, accessibility, widgetstate]
---

Combine `RadioGroup` with `NakedRadio` to build completely custom radio buttons. The group coordinates arrow-key navigation, focus, and selection while each `NakedRadio` exposes a typed state snapshot for styling.

<Info>
  Full examples are available in [`example/lib/api/naked_radio.0.dart`](https://github.com/btwld/naked_ui/blob/main/example/lib/api/naked_radio.0.dart).
</Info>

## Quick Start

```dart
enum RadioOption { banana, apple }

class RadioExample extends StatefulWidget {
  const RadioExample({super.key});

  @override
  State<RadioExample> createState() => _RadioExampleState();
}

class _RadioExampleState extends State<RadioExample> {
  RadioOption _selected = RadioOption.banana;

  @override
  Widget build(BuildContext context) {
    return RadioGroup<RadioOption>(
      groupValue: _selected,
      onChanged: (value) => setState(() => _selected = value!),
      child: const Row(
        mainAxisSize: MainAxisSize.min,
        spacing: 12,
        children: [
          _RadioChip(value: RadioOption.banana, label: 'Banana'),
          _RadioChip(value: RadioOption.apple, label: 'Apple'),
        ],
      ),
    );
  }
}

class _RadioChip extends StatelessWidget {
  const _RadioChip({required this.value, required this.label});

  final RadioOption value;
  final String label;

  @override
  Widget build(BuildContext context) {
    return NakedRadio<RadioOption>(
      value: value,
      builder: (context, radioState, _) {
        final bool isSelected = radioState.isSelected;
        final bool isHovered = radioState.isHovered;
        final bool isFocused = radioState.isFocused;

        return AnimatedContainer(
          duration: const Duration(milliseconds: 150),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(20),
            color: isSelected
                ? Colors.blue.shade600
                : isHovered
                    ? Colors.grey.shade200
                    : Colors.white,
            border: Border.all(
              color: isFocused ? Colors.blue : Colors.grey.shade300,
              width: isFocused ? 2 : 1,
            ),
          ),
          child: Row(
            mainAxisSize: MainAxisSize.min,
            children: [
              Text(
                label,
                style: TextStyle(
                  color: isSelected ? Colors.white : Colors.grey.shade800,
                  fontWeight: FontWeight.w600,
                ),
              ),
              if (isSelected) ...[
                const SizedBox(width: 6),
                const Icon(Icons.check, size: 16, color: Colors.white),
              ],
            ],
          ),
        );
      },
    );
  }
}
```

## Typed Radio State

`NakedRadioState<T>` (delivered to the builder) exposes:

- `value` → radio value for this option
- `isSelected` → convenience getter (via `WidgetState.selected`)
- `widgetStates` → hover/focus/pressed/disabled information

### Access from Context

- `NakedRadioState.of<T>(context)` / `maybeOf<T>(context)` → obtain the nearest typed state
- `NakedRadioState.controllerOf(context)` / `maybeControllerOf(context)` → access the underlying `WidgetStatesController` when you need listeners outside the builder

## RadioGroup Constructor

```dart
const RadioGroup({
  Key? key,
  required this.groupValue,
  required this.onChanged,
  required this.child,
})
```

- `groupValue` → the selected value (nullable to allow “no selection”)
- `onChanged` → receives new value when a radio activates
- `child` → subtree that contains your `NakedRadio` widgets

## NakedRadio Constructor

```dart
const NakedRadio<T>({
  Key? key,
  required this.value,
  this.child,
  this.enabled = true,
  this.mouseCursor,
  this.focusNode,
  this.autofocus = false,
  this.toggleable = false,
  this.onFocusChange,
  this.onHoverChange,
  this.onPressChange,
  this.builder,
  this.groupRegistry,
})
```

Key notes:

- Provide either `child` (static content) or `builder` (dynamic styling via `NakedRadioState`)
- `toggleable` lets the selected radio clear the group when activated again
- Pass `focusNode` to integrate with external focus management
- Omit `onPressChange`/`onHoverChange` for lighter usage; they are optional hooks

## Accessibility Tips

- Ensure each radio exposes a label (e.g. text within the builder)
- Default keyboard support: arrow keys move between radios, Space selects
- Keep your focus/hover styles visible using `radioState.isFocused` / `isHovered`
- For more advanced layouts, wrap radio groups in `FocusTraversalGroup` to control traversal order
